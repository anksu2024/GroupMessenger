/**
 * NAME: ANKIT SARRAF
 * EMAIL: sarrafan@buffalo.edu
 * Resources: Discussed with Rahul Singh (rsingh33@buffalo.edu)
 */

package edu.buffalo.cse.cse486586.groupmessenger;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Collections;
import java.util.HashMap;

import android.annotation.SuppressLint;
import android.app.Activity;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.telephony.TelephonyManager;
import android.text.method.ScrollingMovementMethod;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnKeyListener;
import android.widget.EditText;
import android.widget.TextView;

/**
 * GroupMessengerActivity is the main Activity for the assignment.
 * @author stevko and sarrafan
 */

public class GroupMessengerActivity extends Activity {
	//Tag for Logging Activity
	static final String TAG = GroupMessengerActivity.class.getSimpleName();
	
	//Rg : Last correctly ordered Message received
	protected static int Rg = 0;

	//S : The sequence Number that is generated by the Sequence (ONLY)
	protected static int S = 0;

	//AVD specific Hold-Back Queue
	protected HashMap<Integer, String> holdBackQueue;

	@SuppressLint("UseSparseArrays")
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_group_messenger);

		//Initialize empty holdBackQueue
		holdBackQueue = new HashMap<Integer, String>();

		/*
		 * Use the TextView to display your messages. Though there is no grading component
		 * on how you display the messages, if you implement it, it'll make your debugging easier.
		 */

		try {
			ServerSocket serverSocket = new ServerSocket(Constants.SERVER_PORT);
			new ServerTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, serverSocket);
		} catch(IOException e) {
			Log.e(TAG, "Can't create a ServerSocket : " + getMyPort());
			return;
		}

		TextView tv = (TextView) findViewById(R.id.textView1);
		tv.setMovementMethod(new ScrollingMovementMethod());

		/*
		 * Registers OnPTestClickListener for "button1" in the layout, which is the "PTest" button.
		 * OnPTestClickListener demonstrates how to access a ContentProvider.
		 */
		findViewById(R.id.button1).setOnClickListener(new OnPTestClickListener(tv, getContentResolver()));

		/*
		 * Register and implement an OnClickListener for the "Send" button.
		 * In your implementation you need to get the message from the input box (EditText)
		 * and send it to other AVDs in a total-causal order.
		 */
		findViewById(R.id.button4).setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				EditText editText = (EditText)findViewById(R.id.editText1);
				String msg = editText.getText().toString() + "\n";
				editText.setText("");

				sendMessage(msg);

				return;
			}
		});

		final EditText editText1 = (EditText)findViewById(R.id.editText1);

		editText1.setOnKeyListener(new OnKeyListener() {
			@Override
			public boolean onKey(View v, int keyCode, KeyEvent event) {
				if ((event.getAction() == KeyEvent.ACTION_DOWN) && (keyCode == KeyEvent.KEYCODE_ENTER)) {
					/*
					 * If the key is pressed (i.e., KeyEvent.ACTION_DOWN) and it is an enter key
					 * (i.e., KeyEvent.KEYCODE_ENTER), then we display the string. Then we create
					 * an AsyncTask that sends the string to the remote AVD.
					 */
					String msg = editText1.getText().toString() + "\n";
					editText1.setText("");	// Reset the editText

					sendMessage(msg);

					return true;
				}
				return false;
			}
		});
	}

	private String getMyPort() {
		/*Professor's Hack - Taken from SimpleMessenger*/
		TelephonyManager tel = (TelephonyManager) this.getSystemService(Context.TELEPHONY_SERVICE);
		//Log.d(TAG, "Telephony Manager => " + tel.toString());

		String portStr = tel.getLine1Number().substring(tel.getLine1Number().length() - 4);
		//Log.d(TAG, "Port String => " + portStr);

		String myPort = String.valueOf((Integer.parseInt(portStr) * 2));
		//Log.d(TAG, "Value of My Port => " + myPort);

		return myPort;
	}

	class ServerTask extends AsyncTask<ServerSocket, String, Void> {
		@Override
		protected Void doInBackground(ServerSocket ... sockets) {
			System.out.println("In Server");
			ServerSocket serverSocket = sockets[0];

			Socket clientSocket;
			BufferedReader bufferIn;
			String inputLine;

			try {
				while(true) {
					clientSocket = serverSocket.accept();

					bufferIn = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));

					inputLine = bufferIn.readLine();
					if(inputLine.equals(null) || inputLine.equals("") || inputLine == null) {
						//If blank input entered, just break
						Log.i(TAG, "Exit client");
						break;
					}

					int sequenceNumber = Integer.parseInt(inputLine.substring(0, inputLine.indexOf(":")));

					if(sequenceNumber == -1) {
						/*
						 * This is a message that was unicast by an AVD to the Sequencer
						 * Assign this a Sequence Number and Multicast it
						 * This sequence Number = Rg
						 */
						String newMessage = null;

						//Check this
						synchronized(this) {
							newMessage = GroupMessengerActivity.S++ + inputLine.substring(inputLine.indexOf(":"));
							addToHoldBackQueue(newMessage);
							new ClientTask().executeOnExecutor(AsyncTask.SERIAL_EXECUTOR, newMessage, getMyPort());
						}
					}
					else {
						/*
						 * Message that is received from the Sequencer Multicast
						 * Three possibilities according to the conditions stated below
						 */

						if(Rg == sequenceNumber) {
							/*
							 * Most favorable condition
							 * My Rg == sequenceNumber : We are good, Publish and add to the Content Provider
							 */

							addToContentProvider(sequenceNumber, false, inputLine.substring(inputLine.indexOf(":") + 1));

							checkTheHoldBackQueue();
						}
						else {
							if(Rg < S) {
								/*
								 * If Rg < S, the message reached before its predecessor
								 * i.e. Received Message with higher sequence Number as compared to Rg
								 * Throw this message in the holdBackQueue
								 * Wait for the intermediate packets. Add to the Hold Back Queue
								 */

								addToHoldBackQueue(inputLine);
							}
							/*
							 * Oops a duplicate Message. Discard it
							 * Don't do nothing. Move on.
							 */
						}
					}

					bufferIn.close();
					Log.i(TAG, "bufferIn Closed");

					clientSocket.close();
					Log.i(TAG, "clientSocket Closed");
				}
			}
			catch(IOException ie) {
				Log.e(TAG, "Exception => " + ie.getMessage());
			}

			return null;
		}

		private void addToHoldBackQueue(String myMessage) {
			holdBackQueue.put(Integer.parseInt(myMessage.substring(0, myMessage.indexOf(":"))),			//KEY
					myMessage.substring(myMessage.indexOf(":") + 1));									//VALUE

			checkTheHoldBackQueue();
		}

		private void checkTheHoldBackQueue() {
			// Check if the minimum Key in Hold Back Queue is equal to the Rg
			// If yes, Serialize the Key Value pair as ContentValues and insert
			// Else do nothing

			while(!holdBackQueue.isEmpty()) {
				int minKey = Collections.min(holdBackQueue.keySet());
				if(minKey != Rg) {
					//Rg < minKey. So, need to wait for intermediate messages 
					break;
				}

				try {
					addToContentProvider(minKey, true);

					//Key added to the content provider
					//Remove entry from the Hold Back Queue
					holdBackQueue.remove(minKey);
				} catch(Exception e) {
					Log.e(TAG, "Exception while adding to the content Provider => " + e.getMessage());
				}
			}
		}

		private void addToContentProvider(int myKey, boolean fromHoldBackQueue, String ... messageToAdd) {
			Uri mUri = buildUri("content", "edu.buffalo.cse.cse486586.groupmessenger.provider");

			String KEY_FIELD = "key";
			String VALUE_FIELD = "value";				

			ContentValues contentValues = new ContentValues();
			contentValues.put(KEY_FIELD, "" + myKey);
			if(fromHoldBackQueue) {
				contentValues.put(VALUE_FIELD, holdBackQueue.get(myKey));
			} else {
				contentValues.put(VALUE_FIELD, messageToAdd[0]);
			}

			ContentResolver contentResolver = getContentResolver();

			//If this statement is successful, Key added to the content provider
			contentResolver.insert(mUri, contentValues);

			//Display on the Display Screen
			publishProgress(contentValues.get(VALUE_FIELD).toString());

			if(fromHoldBackQueue) {
				//Remove entry from the Hold Back Queue
				holdBackQueue.remove(myKey);
			}

			//Increment Rg by 1
			synchronized(this) {
				Rg++;
			}
		}

		private Uri buildUri(String scheme, String authority) {
			Uri.Builder uriBuilder = new Uri.Builder();
			uriBuilder.authority(authority);
			uriBuilder.scheme(scheme);
			return uriBuilder.build();
		}

		protected void onProgressUpdate(String ... strings) {
			/*
			 * The following code displays what is received in doInBackground().
			 */

			Log.d(TAG, "Value received => " + strings[0]);

			TextView localTextView = (TextView) findViewById(R.id.textView1);
			localTextView.append(strings[0] + "\n");
			return;
		}
	}

	private void sendMessage(String msg) {
		msg = "-1:" + msg;

		//Log.i(TAG, "Calling Client function for sending the following data : " + msg);
		// Passing the message to the Client code to send it to sequencer
		new ClientTask().executeOnExecutor(AsyncTask.SERIAL_EXECUTOR, msg, getMyPort());
		return;
	}
}